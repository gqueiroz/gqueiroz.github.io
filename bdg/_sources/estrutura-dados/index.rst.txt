..
    This file is part of "Notas de Aula do Curso Bancos de Dados Geográficos".
    Copyright 2020-2022, Gilberto Queiroz.


.. include:: ../def.rst


.. _cap_estrutura_dados:

Estruturas de Dados e Métodos de Acesso Multidimensionais
=========================================================


Árvores-R
---------


Uma **Árvore-R** é uma árvore balanceada, com uma estrutura semelhante a uma Árvore-B. Trata-se do método de indexação mais empregado na indústria de bancos de dados geoespaciais, estando presente em produtos como o Oracle Spatial, PostgreSQL/PostGIS e o MySQL.​


Considere o conjunto de retângulos mostrados na :numref:`Figura %s <fig:estrutura-dados:rtree-leaf-rectangles>`. Esses retângulos, numerados de 1 a 20, podem representar, por exemplo, a aproximação geométrica de polígonos ou linhas poligonais.


.. figure:: ../img/sam/rtree-leaf-rectangles.png
    :alt: Esquema de uma Árvore-R
    :width: 70%
    :figclass: align-center
    :name: fig:estrutura-dados:rtree-leaf-rectangles

    Retângulos envolventes das geometrias indexadas.


Uma Árvore-R organiza o espaço subjacente em uma hierarquia de retângulos, possivelmente com sobreposições. A  Árvore-R apresentada na :numref:`Figura %s <fig:estrutura-dados:rtree>` ilustra uma hierarquia criada a partir dos retêngulos da :numref:`Figura %s <fig:estrutura-dados:rtree-leaf-rectangles>`. Nessa árvore, os *nós* ou *páginas internas* são formados por **entradas** definidas por pares :math:`(\text{retângulo}, \text{ponteiro-descendente})`. O retângulo de uma entrada contém os retângulos da sub-árvore indicada pelo ponteiro de ligação. Assim, o retângulo da entrada :math:`R_a` contém os retângulos :math:`A`, :math:`B` e :math:`G`, respectivamente, assim como todos os demais retângulos abaixo deles. As páginas no nível das folhas são formadas por entradas do tipo :math:`(\text{retângulo}, \text{ponteiro-objeto})`, para que seja possível recuperar o objeto indexado. No nosso exemplo, esses retângulos estarão associados a geometrias de uma determinada coluna de uma tabela e, portanto, o índice conterá informações para que a linha possa ser recuperada (``TID``  é a abreviação de *tuple identifier*).


.. figure:: ../img/sam/rtree.png
    :alt: Esquema de uma Árvore-R
    :width: 100%
    :figclass: align-center
    :name: fig:estrutura-dados:rtree

    Esquema de uma Árvore-R.
    

As Figuras :numref:`%s <fig:estrutura-dados:rtree-root-rectangles>` e :numref:`%s <fig:estrutura-dados:rtree-internal-node-rectangles-1>` ilustram a hierarquia de retêngulos definida pela árvore mostrada acima.


.. figure:: ../img/sam/rtree-root-rectangles.png
    :alt: Esquema de uma Árvore-R
    :width: 70%
    :figclass: align-center
    :name: fig:estrutura-dados:rtree-root-rectangles

    Retângulos do *nó raiz* e seus descendentes diretos.


|br|


.. figure:: ../img/sam/rtree-internal-node-rectangles-1.png
    :alt: Agrupando os retângulos envolventes das geometrias em uma nova hierarquia de retângulos
    :width: 70%
    :figclass: align-center
    :name: fig:estrutura-dados:rtree-internal-node-rectangles-1

    Hierarquia dos retângulos dos *nós internos* e das *folhas*.


Uma Árvore-R deve satisfazer as seguintes propriedades:

.. rst-class:: open

- O **número máximo de entradas** em uma *página* é dado por :math:`M`.

- O **número mínimo de entradas** em uma página é definido como :math:`m = \lceil \frac{M}{2}  \rceil`. Esse parâmetro é responsável pelo balanceamento da árvore.

- Toda *página* contém entre :math:`m` e :math:`M` entradas válidas. A única exceção é o *nó raiz*.

- Se a árvore tiver mais do que um nível, isto é, pelo menos :math:`altura = 1`, a raiz terá ao menos dois descendentes.

- Para cada entrada dos *nós internos*, que são formados por entradas representadas pelos pares :math:`(\text{retângulo}, \text{ponteiro-descendente})`, o :math:`retângulo` dessa entrada será o menor retângulo a conter todos os retângulos das entradas do *nó descendente*. Repare nas figuras acima, que o retângulo :math:`R_a` contém os retângulos :math:`A`, :math:`B` e :math:`G`. Por sua vez, o retângulo :math`G` contém o retângulos :math:`R_{10}`, :math:`R_{13}` e :math:`R_{17}`.

- Para cada entrada dos *nós folhas*, que são formados por entradas representadas pelos pares :math:`(\text{retângulo}, \text{ponteiro-objeto})`, o :math:`retângulo` dessa entrada será o retângulo envolvente do objeto indexado. 

- Todas as folhas encontram-se no mesmo nível.

- A altura :math:`h` de uma Árvore-R indexando :math:`n` objetos espaciais é: :math:`h \leqslant (\log_m n) - 1`.


Como é o algoritmo de busca nessa árvore?


Árvores-R no PostgreSQL com PostGIS
+++++++++++++++++++++++++++++++++++


O PostGIS implementa uma Árvore-R sobre o GiST do PostgreSQL. Para criar um **índice espacial** associado a uma **coluna geométrica**, podemos usar o comando ``CREATE INDEX`` com seguinte sintaxe:


.. code-block:: postgresql

    CREATE INDEX <nome-indice> ON <nome-tabela> USING GIST ( <coluna-geometrica> );


A opção ``USING GIST`` indica que o método de indexação a ser usado na criação do índice deverá ser baseado no GiST. Desta forma, o índice criado será uma Árvore-R no caso do tipo ``GEOMETRY`` do PostGIS.


O índice espacial baseado no GIST é importante para consultas envolvendo relacionamentos topológicos, como ``ST_Contains``, ``ST_Within``, ``ST_CoveredBy``, ``ST_Covers``, ``ST_Crosses``, ``ST_Equals``, ``ST_Overlaps``, ST_Touches e ``ST_Intersects``. Esses operadores na verdade utilizam automaticamente um teste entre os retângulos envolventes das geometrias antes de realizar um processamento completo dos vértices das duas geometrias. Nas consultas, o teste baseado em retângulo pode explorar o uso do índice espacial. Por isso , esses operadores topológicos são definidos da seguinte forma:




Assim como no caso do índice baseado em Árvore-B\ :sup:`+`, onde operadores como ``<``, ``>``, ``<=``, ``>=`` e ``=`` permitem explorar a existência de índices no processamento de uma consulta, com o tipo ``GEOMETRY`` do PostGIS, também temos um conjunto de operadores que podem explorar a existência de um índice espacial. Os seguintes operadores podem ser usados pelo processador de consultas para explorar um índice espacial:

.. rst-class:: open

- ``<<``: Em expressões como ``geometria-1 << geometria-2``, o operador ``<<`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` encontra-se completamente à esquerda do retângulo envolvente da ``geometria-2``.

- ``>>``: Em expressões como ``geometria-1 >> geometria-2``, o operador ``>>`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` encontra-se completamente à direita do retângulo envolvente da ``geometria-2``.

- ``<<|``: Em expressões como ``geometria-1 <<| geometria-2``, o operador ``<<|`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` encontra-se completamente abaixo do retângulo envolvente da ``geometria-2``.

- ``|>>``: Em expressões como ``geometria-1 |>> geometria-2``, o operador ``|>>`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` encontra-se completamente acima do retângulo envolvente da ``geometria-2``.

- ``&<``: Em expressões como ``geometria-1 &< geometria-2``, o operador ``&<`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` sobrepõem ou encontra-se à esquerda do retângulo envolvente da ``geometria-2``.

- ``&>``: Em expressões como ``geometria-1 &> geometria-2``, o operador ``&>`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` sobrepõem ou encontra-se à direita do retângulo envolvente da ``geometria-2``.

- ``&<``: Em expressões como ``geometria-1 &<| geometria-2``, o operador ``&<`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` sobrepõem ou encontra-se abaixo do retângulo envolvente da ``geometria-2``.

- ``|&>``: Em expressões como ``geometria-1 |&> geometria-2``, o operador ``|&>`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` sobrepõem ou encontra-se acima do retângulo envolvente da ``geometria-2``.

- ``&&``: Em expressões como ``geometria-1 && geometria-2``, o operador ``&&`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` intercepta o retângulo envolvente da ``geometria-2``. Isso significa que se os retângulos tiverem qualquer interação espacial, esse operador retornar ``TRUE``.

- ``@``: Em expressões como ``geometria-1 @ geometria-2``, o operador ``@`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` encontra-se completamente contido no retângulo envolvente da ``geometria-2``.

- ``~``: Em expressões como ``geometria-1 ~ geometria-2``, o operador ``~`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` contem completamente o retângulo envolvente da ``geometria-2``.

- ``~=``: Em expressões como ``geometria-1 ~= geometria-2``, o operador ``~=`` retorna ``TRUE`` se o retângulo envolvente da ``geometria-1`` é exatamente igual ao retângulo envolvente da ``geometria-2``.




.. note::

    A sintaxe acima cria um índice bidimensional. Para criar um índice :math:`n\text{-dimensional}` para tipos geométricos 3D, com :math:`n > 2`, podemos utilizar a seguinte sintaxe:


    .. code-block:: postgresql

        CREATE INDEX <nome-indice> ON <nome-tabela> USING GIST (<coluna-geometrica> gist_geometry_ops_nd);


.. tip::

    Ao criar um índice espacial, lembre-se de atualizar as estatísticas da tabela:


    .. code-block:: postgresql

        ANALYZE <nome-tabela>


    ou:


    .. code-block:: postgresql

        VACUUM ANALYZE <nome-tabela>


.. note::

    Vamos ver a definição das tabelas com colunas geométricas importadas para o banco de dados.


.. _cap_estrutura_dados_exercicios:

Exercícios
----------


**Exercício 1.** Vamos criar uma tabela chamada ``pts_pgis`` com a seguinte definição:


.. code-block:: sql

    CREATE TABLE pts_pgis
    (
        id     UUID DEFAULT gen_random_uuid(),
        geom   GEOMETRY(POINT, 4326),
        word   TEXT
    );


Em seguida, vamos inserir um conjunto sintético de dados nessa tabela:


.. code-block:: sql

    INSERT INTO pts_pgis (geom, word)
             (
                 SELECT ST_SetSRID(
                            ST_MakePoint(
                                360.0 * random() - 180.0,
                                180.0 * random() - 90.0
                            ),
                            4326
                        ), 
                        rpad(i::text, 10) AS word
                   FROM generate_series(1, 1000000) AS i
             );


Verifique como a seguinte consulta é realizada:


.. code-block:: postgresql

    EXPLAIN ANALYZE
        SELECT * 
          FROM pts_pgis
         WHERE ST_Intersects( geom, ST_MakeEnvelope(1.0, 1.0, 2.0, 2.0, 4326) );


**Exercício 2.** Crie um índice espacial sobre a coluna ``geom`` da tabela ``pts_pgis``:


.. code-block:: postgresql

    CREATE INDEX pts_pgis_geom_idx ON pts_pgis USING GiST ( geom );


Em seguida, refaça as estatísticas sobre a tabela:


.. code-block:: postgresql

    ANALYZE pts_pgis;


Analise novamente a consulta abaixo:


.. code-block:: postgresql

    EXPLAIN ANALYZE
        SELECT * 
          FROM pts_pgis
         WHERE ST_Intersects( geom, ST_MakeEnvelope(1.0, 1.0, 2.0, 2.0, 4326) );
