<!DOCTYPE html>
<html class="writer-html5" lang="pt-BR" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2.23. Índices - Estruturas de Acesso &mdash; BDGeo</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../_static/table_styling.css" type="text/css" />
      <link rel="stylesheet" href="../_static/bd-geoespacial.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="canonical" href="https://prog-geo.github.io/sgbd/indexes.html" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script src="../_static/translations.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Buscar" href="../search.html" />
    <link rel="next" title="2.24. Removendo Objetos do Banco de Dados" href="removendo-objetos.html" />
    <link rel="prev" title="2.22. Importando e Exportando Dados" href="import-export.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #F0F8FF" >
            <a href="../index.html" class="icon icon-home"> BDGeo
            <img src="../_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Pesquisar documentos" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Menu de navegação">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">Bancos de Dados Geográficos</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Aulas:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../instalacao/index.html">1. Instalando e Configurando o Ambiente de Trabalho</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">2. Sistemas de Bancos de Dados Relacionais</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="postgresql.html">2.1. PostgreSQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="pgadmin4.html">2.2. pgAdmin</a></li>
<li class="toctree-l2"><a class="reference internal" href="tour-sql.html">2.3. Um Tour pela Linguagem SQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="conectando-bd.html">2.4. Conectando ao Servidor PostgreSQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="criando-bd.html">2.5. Criando um Novo Banco de Dados no PostgreSQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="tipos-dados-sql.html">2.6. Tipos de Dados SQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="tipos-numericos.html">2.7. Tipos Numéricos</a></li>
<li class="toctree-l2"><a class="reference internal" href="tipo-logico.html">2.8. Tipo Lógico</a></li>
<li class="toctree-l2"><a class="reference internal" href="op-relacionais.html">2.9. Operadores Relacionais</a></li>
<li class="toctree-l2"><a class="reference internal" href="strings.html">2.10. Tipos Textuais</a></li>
<li class="toctree-l2"><a class="reference internal" href="tipos-data-hora.html">2.11. Tipos de Dados para Data e Hora</a></li>
<li class="toctree-l2"><a class="reference internal" href="expressoes.html">2.12. Expressões</a></li>
<li class="toctree-l2"><a class="reference internal" href="criando-tabelas.html">2.13. Criando Tabelas</a></li>
<li class="toctree-l2"><a class="reference internal" href="inserindo-dados.html">2.14. Inserindo Dados</a></li>
<li class="toctree-l2"><a class="reference internal" href="consultas.html">2.15. Consultas em SQL</a></li>
<li class="toctree-l2"><a class="reference internal" href="atualizando-dados.html">2.16. Atualizando Dados</a></li>
<li class="toctree-l2"><a class="reference internal" href="removendo-dados.html">2.17. Removendo Dados</a></li>
<li class="toctree-l2"><a class="reference internal" href="restricoes-integridade.html">2.18. Restrições de Integridade</a></li>
<li class="toctree-l2"><a class="reference internal" href="criando-views.html">2.19. Criando Views</a></li>
<li class="toctree-l2"><a class="reference internal" href="esquemas.html">2.20. Esquemas</a></li>
<li class="toctree-l2"><a class="reference internal" href="alterando-estrutura.html">2.21. Alterando a Estrutura de uma Tabela</a></li>
<li class="toctree-l2"><a class="reference internal" href="import-export.html">2.22. Importando e Exportando Dados</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2.23. Índices - Estruturas de Acesso</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#funcoes-hash">2.23.1. Funções <em>Hash</em></a></li>
<li class="toctree-l3"><a class="reference internal" href="#arvores">2.23.2. Árvores</a></li>
<li class="toctree-l3"><a class="reference internal" href="#indexacao-no-postgresql">2.23.3. Indexação no PostgreSQL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#verificando-o-plano-de-execucao-de-uma-consulta-no-postgresql">2.23.4. Verificando o Plano de Execução de uma Consulta no PostgreSQL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#exercicios">2.23.5. Exercícios</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="removendo-objetos.html">2.24. Removendo Objetos do Banco de Dados</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tipos-geometricos/index.html">3. Tipos de Dados e Operações Espaciais</a></li>
<li class="toctree-l1"><a class="reference internal" href="../estrutura-dados/index.html">4. Estruturas de Dados e Métodos de Acesso Multidimensionais</a></li>
<li class="toctree-l1"><a class="reference internal" href="../algo-geom/index.html">5. Algoritmos Geométricos</a></li>
<li class="toctree-l1"><a class="reference internal" href="../json/index.html">6. JSON (Java Script Object Notation)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../prog-servidor/index.html">7. Programação do Lado Servidor no PostgreSQL</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tips/index.html">8. Dicas</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Referências Bibliográficas</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../referencias.html">Referências Bibliográficas</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Listas de Exercícios:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../listas.html">Listas de Exercícios</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Informações Gerais:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../licenca.html">Licença</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Agradecimentos:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../agradecimentos.html">Agradecimentos</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Menu de navegação móvel"  style="background: #F0F8FF" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">BDGeo</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Navegação da página">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="index.html"><span class="section-number">2. </span>Sistemas de Bancos de Dados Relacionais</a> &raquo;</li>
      <li><span class="section-number">2.23. </span>Índices - Estruturas de Acesso</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Navegação sequencial da página">
        <a href="import-export.html" class="btn btn-neutral float-left" title="2.22. Importando e Exportando Dados" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Anterior</a>
        <a href="removendo-objetos.html" class="btn btn-neutral float-right" title="2.24. Removendo Objetos do Banco de Dados" accesskey="n">Próximo <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="indices-estruturas-de-acesso">
<span id="cap-sgbd-indexes"></span><h1><span class="section-number">2.23. </span>Índices - Estruturas de Acesso<a class="headerlink" href="#indices-estruturas-de-acesso" title="Link permanente para este cabeçalho"></a></h1>
<p>Muitas vezes, as aplicações que trabalham com bancos de dados são projetadas de maneira a manipular apenas uma fração dos dados desse banco. As aplicações OLTP (<em>Online Transaction Processing</em>), por exemplo, possuem esta característica. Consequentemente, ter apenas os arquivos das tabelas do banco de dados organizados em linhas armazenadas sequencialmente, sem uma forma de localizar rapidamente uma linha ou conjunto de linhas dependendo do valor de um determinado campo, pode acarretar em problemas de desempenho, principalmente, quando temos tabelas com muitas linhas e com volumes de dados que não são comportados em memória principal. Logo, estruturas de dados auxiliares que ajudem a localizar rapidamente uma linha ou um subconjunto das linhas de uma tabela, são imprescindíveis para um SGBD.</p>
<p>Vamos retomar a tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code> criada no <a class="reference internal" href="import-export.html#cap-sgbd-import-export-ex-1"><span class="std std-ref">Exercício 1</span></a> da <a class="reference internal" href="import-export.html#cap-sgbd-import-export"><span class="std std-numref">Seção 2.22 - Importando e Exportando Dados</span></a>. Essa tabela contém 5.570 linhas e possui a seguinte definição:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">municipio</span><span class="w"></span>
<span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">id</span><span class="w">   </span><span class="nb">CHAR</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">nome</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Em um SGBD relacional, como o PostgreSQL, o fato de definir uma ou mais colunas como chave primária, faz com que o SGBD tenha que verificar o valor desses campos nas operações de inserção (<code class="docutils literal notranslate"><span class="pre">INSERT</span></code>) e atualização (<code class="docutils literal notranslate"><span class="pre">UPDATE</span></code>). Essa verificação depende de um acesso rápido às linhas da tabela para identificar se o valor de chave primária fornecido na operação já existe na tabela. Como as operações de inserção, remoção e atualização podem fazer com que as linhas da tabela não respeitem a ordem da chave primária, é necessária uma estrutura de dados auxiliar que ajude a localizar rapidamente uma linha que contenha a chave primária. Por isso, o PostgreSQL cria automaticamente um índice associado às colunas que compõem a chave primária. Este é o caso da coluna <code class="docutils literal notranslate"><span class="pre">id</span></code> da tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code>, conforme mostrado na descrição dessa tabela pelo aplicativo <em>psql</em>:</p>
<div class="highlight-psql notranslate"><div class="highlight"><pre><span></span><span class="kp">\d</span><span class="w"> </span><span class="ss">municipio</span>
</pre></div>
</div>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>                    Table &quot;public.municipio&quot;
 Column |         Type          | Collation | Nullable | Default
--------+-----------------------+-----------+----------+---------
 id     | character(7)          |           | not null |
 nome   | character varying(40) |           | not null |
Indexes:
    &quot;municipio_pkey&quot; PRIMARY KEY, btree (id)
</pre></div>
</div>
<p>Repare na saída acima que um índice denominado <code class="docutils literal notranslate"><span class="pre">municipio_pkey</span></code> foi criado, associado à coluna <code class="docutils literal notranslate"><span class="pre">id</span></code> que é chave primária. A saída acima também indica que esse índice é do tipo <code class="docutils literal notranslate"><span class="pre">btree</span></code>. Mais adiante neste capítulo, será discutido os vários tipos de índices e suas aplicações. Por hora, vamos compreender como o PostgreSQL executa uma consulta envolvendo a busca por um valor de chave primária. O comando <code class="docutils literal notranslate"><span class="pre">EXPLAIN</span></code> do PostgreSQL junto à opção <code class="docutils literal notranslate"><span class="pre">ANALYZE</span></code> apresenta o plano a ser usado na execução de uma consulta. O comando abaixo exibe como o PostgreSQL irá recuperar a linha com <code class="docutils literal notranslate"><span class="pre">id</span></code> de valor <code class="docutils literal notranslate"><span class="pre">2112704</span></code>:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="p">(</span><span class="k">ANALYZE</span><span class="w"> </span><span class="k">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">FORMAT</span><span class="w"> </span><span class="n">YAML</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">municipio</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;2112704&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>                 QUERY PLAN
--------------------------------------------
 - Plan:                                   +
<span class="hll">     Node Type: &quot;Index Scan&quot;               +
</span>     Parallel Aware: false                 +
     Async Capable: false                  +
     Scan Direction: &quot;Forward&quot;             +
<span class="hll">     Index Name: &quot;municipio_pkey&quot;          +
</span>     Relation Name: &quot;municipio&quot;            +
     Alias: &quot;municipio&quot;                    +
     Startup Cost: 0.28                    +
     Total Cost: 8.30                      +
     Plan Rows: 1                          +
     Plan Width: 21                        +
     Actual Startup Time: 0.038            +
     Actual Total Time: 0.041              +
     Actual Rows: 1                        +
     Actual Loops: 1                       +
<span class="hll">     Index Cond: &quot;(id = &#39;2112704&#39;::bpchar)&quot;+
</span>     Rows Removed by Index Recheck: 0      +
   Planning Time: 0.142                    +
   Triggers:                               +
   Execution Time: 0.074
(1 row)
</pre></div>
</div>
<p>As linhas destacadas na saída acima indicam que o PostgreSQL irá utilizar uma estratégia de consulta baseada no índice <code class="docutils literal notranslate"><span class="pre">municipio_pkey</span></code> associado à coluna <code class="docutils literal notranslate"><span class="pre">id</span></code>. Essa estratégia faz com que o PostgreSQL seja muito eficiente na busca da linha procurada.</p>
<p>Vamos agora verificar como o PostgreSQL trata uma consulta aonde ele não poderá contar com um índice auxiliar. Para isso, vamos construir uma consulta nessa mesma tabela que recupere a linha do município de nome <code class="docutils literal notranslate"><span class="pre">Araxá</span></code>:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="p">(</span><span class="k">ANALYZE</span><span class="w"> </span><span class="k">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">FORMAT</span><span class="w"> </span><span class="n">YAML</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">municipio</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">nome</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Araxá&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>                 QUERY PLAN
----------------------------------------------
 - Plan:                                     +
<span class="hll">     Node Type: &quot;Seq Scan&quot;                   +
</span>     Parallel Aware: false                   +
     Async Capable: false                    +
     Relation Name: &quot;municipio&quot;              +
     Alias: &quot;municipio&quot;                      +
     Startup Cost: 0.00                      +
<span class="hll">     Total Cost: 105.62                      +
</span>     Plan Rows: 1                            +
     Plan Width: 21                          +
     Actual Startup Time: 1.341              +
     Actual Total Time: 3.603                +
     Actual Rows: 1                          +
     Actual Loops: 1                         +
<span class="hll">     Filter: &quot;((nome)::text = &#39;Araxá&#39;::text)&quot;+
</span><span class="hll">     Rows Removed by Filter: 5569            +
</span>   Planning Time: 0.195                      +
   Triggers:                                 +
   Execution Time: 3.637
(1 row)
</pre></div>
</div>
<p>Nesse caso, sem uma estrutura de dados auxiliar, o SGBD precisará verificar todas as linhas da tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code> para localizar a linha ou linhas que possuem o valor <code class="docutils literal notranslate"><span class="pre">Araxá</span></code> no campo <code class="docutils literal notranslate"><span class="pre">nome</span></code>. As linhas destacadas na saída acima mostram que o PostgreSQL irá varrer os registros da tabela de maneira sequencial e que por isso, 5.569 linhas serão verificadas e descartadas, para resultar apenas na linha de <code class="docutils literal notranslate"><span class="pre">Araxá</span></code>. Portanto, os índices são usados justamente para evitar esse tipo de situação. Ao definir um índice sobre a coluna <code class="docutils literal notranslate"><span class="pre">nome</span></code>, a estrutura de dados auxiliar criada possibilitará ao SGDB localizar a linha ou linhas de interesse sem a necessidade de realizar a leitura de toda a tabela.</p>
<p>A existência de estruturas de dados ou índices bem projetados nos SGBDs é fundamental para minimizar o acesso a disco. Ainda hoje, muitos sistemas de bancos de dados operam com conjuntos de discos mecânicos que possuem um esquema semelhante ao mostrado na <a class="reference internal" href="#fig-sgbd-indexes-hd-schematic"><span class="std std-numref">Figura 2.31</span></a>. Portanto, um dos objetivos dos SGBDs é diminuir a quantidade de operações de leitura realizadas entre esse tipo de equipamento e a memória RAM, onde os dados são mantidos para posterior operação.</p>
<figure class="align-center align-default" id="fig-sgbd-indexes-hd-schematic">
<a class="reference internal image-reference" href="../_images/hd-schematic.png"><img alt="Figura esquemática de um disco rígido mecânico" src="../_images/hd-schematic.png" style="width: 75%;" /></a>
<figcaption>
<p><span class="caption-number">Figura 2.31 - </span><span class="caption-text">Figura esquemática de um disco rígido mecânico. <br/> <strong>Fonte:</strong> Wirzenius et al. <span id="id1">[<a class="reference internal" href="../referencias.html#id35" title="Lars Wirzenius, Joanna Oja, Stephen Stafford, and Alex Weeks. The linux system administrator's guide. 2022. Online; acessado 23 de Outubro de 2022. URL: https://tldp.org/LDP/sag/html/index.html.">31</a>]</span>.</span><a class="headerlink" href="#fig-sgbd-indexes-hd-schematic" title="Link Permanente para essa imagem"></a></p>
</figcaption>
</figure>
<p>Existem dois conjuntos de métodos bem consolidados na literatura que são usados pelos SGBDs para indexar dados: as <strong>funções hash</strong> e as estruturas de dados conhecidas por <strong>árvores</strong>. Nessa seção iremos examinar os fundamentos desses métodos bem como a criação de índices no PostgreSQL para os tipos de dados básicos (números inteiros e reais, strings, data e hora) e mais adiante no curso, retomaremos essa discussão com os tipos <em>JSON</em> e <em>PostGIS Geometry</em>.</p>
<section id="funcoes-hash">
<h2><span class="section-number">2.23.1. </span>Funções <em>Hash</em><a class="headerlink" href="#funcoes-hash" title="Link permanente para este cabeçalho"></a></h2>
<p><strong>EM DESENVOLVIMENTO</strong></p>
</section>
<section id="arvores">
<h2><span class="section-number">2.23.2. </span>Árvores<a class="headerlink" href="#arvores" title="Link permanente para este cabeçalho"></a></h2>
<p><strong>Definição:</strong> Uma árvore é definida como um conjunto finito de um ou mais <strong>nós</strong> (em Inglês, <strong>nodes</strong>), sendo um deles designado <strong>raiz</strong> (em Inglês, <strong>root node</strong>), e os demais elementos, particionados em <span class="math notranslate nohighlight">\(k \geqslant 0\)</span> conjuntos disjuntos, <span class="math notranslate nohighlight">\(T_1, ..., T_k\)</span>, em que cada um desses conjuntos também são árvores <span id="id2">[<a class="reference internal" href="../referencias.html#id22" title="Ellis Horowitz, Sartaj Sahni, and Sanguthevar Rajasekaran. Computer Algorithms. PComputer Science Press, 1 edition, 1997.">20</a>]</span>. A <a class="reference internal" href="#fig-sgbd-indexes-definicao-arvore"><span class="std std-numref">Figura 2.32</span></a> ilustra essa definição.</p>
<figure class="align-center align-default" id="fig-sgbd-indexes-definicao-arvore">
<a class="reference internal image-reference" href="../_images/definicao-arvore.png"><img alt="Definição de árvores com raiz" src="../_images/definicao-arvore.png" style="width: 60%;" /></a>
<figcaption>
<p><span class="caption-number">Figura 2.32 - </span><span class="caption-text">Definição de árvores com <strong>raiz</strong>.</span><a class="headerlink" href="#fig-sgbd-indexes-definicao-arvore" title="Link Permanente para essa imagem"></a></p>
</figcaption>
</figure>
<p>Pela definição acima, a estrutura de dados árvore é uma <strong>estrutura recursiva</strong> pois cada um dos conjuntos <span class="math notranslate nohighlight">\(T_i\)</span>, com <span class="math notranslate nohighlight">\(1 \leqslant i \leqslant k\)</span>, também são árvores.</p>
<section id="arvores-binarias-de-pesquisa">
<h3><span class="section-number">2.23.2.1. </span>Árvores Binárias de Pesquisa​<a class="headerlink" href="#arvores-binarias-de-pesquisa" title="Link permanente para este cabeçalho"></a></h3>
<p>A <a class="reference internal" href="#fig-sgbd-indexes-arvores-binarias-pesquisa"><span class="std std-numref">Figura 2.33</span></a> apresenta uma estrutura conhecida por <strong>árvore binária de pesquisa</strong> (em Inglês, <strong>binary search tree</strong>).</p>
<figure class="align-center align-default" id="fig-sgbd-indexes-arvores-binarias-pesquisa">
<a class="reference internal image-reference" href="../_images/arvores-binarias-pesquisa.png"><img alt="Árvore Binária de Pesquisa" src="../_images/arvores-binarias-pesquisa.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-number">Figura 2.33 - </span><span class="caption-text">Árvore Binária de Pesquisa.</span><a class="headerlink" href="#fig-sgbd-indexes-arvores-binarias-pesquisa" title="Link Permanente para essa imagem"></a></p>
</figcaption>
</figure>
<p>​Numa árvore binária de pesquisa, os <em>nós</em> possuem chave única, isto é, não há valores duplicados de chave. O <em>nó</em> superior é denominado <strong>raiz da árvore</strong>. Na figura, o <em>nó</em> com chave de valor 18 é a raiz dessa árvore. Os <em>nós</em> à esquerda do <em>nó raiz</em> formam a <strong>sub-árvore esquerda</strong>, enquanto os <em>nós</em> à direita, formam a <strong>sub-árvore direita</strong>. Os valores de chave da sub-árvore esquerda são menores que as da sub-árvore direita. As chaves da sub-árvore esquerda são menores do que a da raiz. As chaves da sub-árvore direita são maiores do que a da raiz. As sub-árvores esquerda e direita também são árvores binárias de pesquisa. Repare que o <em>nó</em> com chave de valor 11 pode ser visto como a raiz de uma nova árvore e que a relação entre os valores de chave (à esquerda dos nós e à direita dos nós) são preservados nessa sub-árvore.</p>
<p>Essa estrutura permite realizar buscas por valores de chave muito facilmente e, se bem estruturada, de forma eficiente. Suponha que estejamos procurando a chave 70. Começamos a busca pela raiz da árvore, que possui o valor 18. Como o valor procurado é maior que a chave 18, os nós da sub-árvore esquerda não precisarão ser pesquisados, uma vez que todos os valores​ de chave dessa sub-árvore também serão menores que 18. Assim, a busca continua no <em>nó</em> à direita da raiz, que possui chave de valor 78. Como a chave procurada é menor que 78, podemos descartar todos os nós da sub-árvore à direita do nó 78, concentrando a busca na sub-árvore esquerda, que possui o nó com valor de chave 65. Como a chave procurada é maior que 65, tomamos o caminho da sub-árvore direita, chegando ao <em>nó</em> de chave 70, que é igual ao valor procurado e, assim, nossa busca termina com sucesso. Em resumo, a busca pela chave 70 nos levou a examinar os nós <span class="math notranslate nohighlight">\(\{18, 78, 65, 70\}\)</span>. Isso significa que a busca em uma árvore binária de pesquisa depende, essencialmente, da altura ou profundidade dela.</p>
<p>Numa estrutura de árvore binária de pesquisa como a da <a class="reference internal" href="#fig-sgbd-indexes-arvores-binarias-pesquisa"><span class="std std-numref">Figura 2.33</span></a>, temos as seguintes definições:</p>
<ul class="open">
<li><p>Os elementos indicados por círculos são denominados <strong>nós</strong>. Nessa árvore temos, portanto, 15 <em>nós</em>.</p></li>
<li><p>Os valores apresentados dentro de cada <em>nó</em> são denominados de <strong>chave</strong> (em Inglês, <strong>key</strong>).</p></li>
<li><p>O <strong>grau de um nó</strong> é definido como o número de sub-árvores deste <em>nó</em>. Nessa figura, o grau do <em>nó</em> de chave 18 é 2, isto é, ele possui dois descendentes diretos. O grau do <em>nó</em> de chave 5 é 0, isto é, ele não possui descedentes.</p></li>
<li><p>O <strong>grau máximo</strong> numa <strong>árvore binária</strong> é <strong>dois</strong>. Portanto, podemos ter <em>nós</em> com zero, um ou dois descendentes.</p></li>
<li><p>Os <em>nós</em> que não possuem descendentes são denominados <strong>folha</strong> (em Inglês, <strong>leaf node</strong>) ou <strong>terminais</strong> (em Inglês, <strong>terminal</strong>). Na figura, os <em>nós</em> <span class="math notranslate nohighlight">\(\{5, 9, 13, 17, 32, 70, 85, 98\}\)</span> são <em>folha</em>.</p></li>
<li><p>Os <em>nós</em> que não são <em>folha</em>, são chamados de <strong>internos</strong> ou <strong>não-terminais</strong>. Os <em>nós</em> de chave <span class="math notranslate nohighlight">\(\{11, 78, 8, 16, 65, 90\}\)</span> são considerados <em>nós internos</em> ou <em>nós não-terminais</em>.</p></li>
<li><p>Os <em>nós</em> que são raízes das sub-árvores de um <em>nó</em> <span class="math notranslate nohighlight">\(x\)</span> da árvore, são chamados de <strong>filhos</strong> (em Inglês, <strong>children nodes</strong>) do <em>nó</em> <span class="math notranslate nohighlight">\(x\)</span>. Por exemplo, os elementos <em>filhos</em> do <em>nó</em> de chave 78 são: <span class="math notranslate nohighlight">\(\{65, 90\}\)</span>. O <em>nó</em> <span class="math notranslate nohighlight">\(x\)</span> é <strong>pai</strong> (em Inglês, <strong>parent node</strong>) de seus <em>filhos</em>.​ Por exemplo, o <em>nó pai</em> do <em>nó</em> de chave 90 é o <em>nó</em> de chave 78.</p></li>
<li><p>Os <em>nós filhos</em> de um mesmo <em>nó</em> são chamados de <strong>irmãos</strong> (em Inglês, <strong>sibling nodes</strong>).</p></li>
<li><p>Os <strong>ancestrais de um nó</strong> (em Inglês, <strong>ancestors</strong>) são todos os <em>nós</em> no caminho da raiz até o <em>nó</em> em questão. Por exemplo, os <em>ancestrais</em> do <em>nó</em> com chave 70 são: <span class="math notranslate nohighlight">\(\{18, 78, 65\}\)</span>.</p></li>
<li><p>O <strong>nível</strong> de um <em>nó</em> é definido tomando a <em>raiz</em> como nível 0. Se um <em>nó</em> encontra-se no nível <span class="math notranslate nohighlight">\(i\)</span>, seus filhos encontram-se no nível <span class="math notranslate nohighlight">\(i + 1\)</span>.​</p></li>
<li><p>A <strong>altura</strong> (<strong>height</strong>) ou <strong>profundidade</strong> (<strong>depth</strong>) de uma árvore é o maior nível de qualquer <em>nó</em> dessa árvore.​ Existem duas convenções para se definir a altura de uma árvore binária: (a) o número de <em>nós</em> no maior caminho da raiz até a <em>folha</em> mais profunda; (b)​ o número de arestas no caminho mais comprido da raiz até a <em>folha</em>. Na <a class="reference internal" href="#fig-sgbd-indexes-arvores-binarias-pesquisa"><span class="std std-numref">Figura 2.33</span></a> ​adotamos a segunda convenção, isto é, <em>o número de arestas no caminho mais comprido da raiz até a</em>. Portanto, a árvore mostrada nessa figura possui altura 3.</p></li>
<li><p>A árvore da <a class="reference internal" href="#fig-sgbd-indexes-arvores-binarias-pesquisa"><span class="std std-numref">Figura 2.33</span></a> é uma <strong>árvore binária plena</strong> ou <strong>árvore binária cheia</strong> pois todas as folhas encontram-se no mesmo nível. Repare que tanto a <em>raiz</em> quanto todos os <em>nós internos</em> possuem dois filhos.</p></li>
</ul>
<p>Essa estrutura de dados nos permite estabelecer algumas fórmulas e propriedades interessantes:</p>
<ul class="open">
<li><p>​O número máximo de nós no nível <span class="math notranslate nohighlight">\(i\)</span> é <span class="math notranslate nohighlight">\(2^{i}\)</span>, <span class="math notranslate nohighlight">\(i \geq 0\)</span>. Desta forma, o <em>nível 0</em> (a <em>raiz</em>) terá no máximo <em>1 nó</em>. O <em>nível 1</em> terá <em>2 nós</em>. O <em>nível 2</em> terá <em>4 nós</em>. O <em>nível 3</em> terá <em>8 nós</em>. Se tivermos uma árvore de <em>altura 10</em>, no último nível, isto é, o <em>nível 9</em>, teremos no máximo <em>512 nós</em>.</p></li>
<li><p>O número máximo de <em>nós</em> <span class="math notranslate nohighlight">\(n\)</span> de uma árvore binária de altura <span class="math notranslate nohighlight">\(h\)</span> é dado por: <span class="math notranslate nohighlight">\(n = \sum_{i=0}^{h} 2^{i}\)</span>, ou seja, <span class="math notranslate nohighlight">\(n = 2^{h + 1} - 1, h \geq 0\)</span>. Na árvore da <a class="reference internal" href="#fig-sgbd-indexes-arvores-binarias-pesquisa"><span class="std std-numref">Figura 2.33</span></a>, temos <em>altura 3</em> e, logo, <span class="math notranslate nohighlight">\(n = 2^4 - 1 = 15\ nós\)</span>.</p></li>
<li><p>A altura de uma árvore binária plena com <span class="math notranslate nohighlight">\(n\)</span> <em>nós</em> é: <span class="math notranslate nohighlight">\(h = \log_2(n + 1) - 1\)</span>, com <span class="math notranslate nohighlight">\(n \geq 1\)</span>.</p></li>
<li><p>Se uma árvore plena possui <span class="math notranslate nohighlight">\(n\)</span> <em>nós</em> na folha, o nível <span class="math notranslate nohighlight">\(i\)</span> das folhas será dado por​ <span class="math notranslate nohighlight">\(i = (\log_2 n)\)</span>. Na árvore da <a class="reference internal" href="#fig-sgbd-indexes-arvores-binarias-pesquisa"><span class="std std-numref">Figura 2.33</span></a>, temos <em>8 nós folha</em>, logo, o nível será dados por <span class="math notranslate nohighlight">\(\log_2 8 = \log_2 2^3 = 3\)</span>.</p></li>
</ul>
</section>
<section id="arvores-balanceadas">
<h3><span class="section-number">2.23.2.2. </span>Árvores Balanceadas<a class="headerlink" href="#arvores-balanceadas" title="Link permanente para este cabeçalho"></a></h3>
<p>As árvores binárias de pesquisa com altura <span class="math notranslate nohighlight">\(O(\log_2n)\)</span> são conhecidas como <strong>árvores balanceadas</strong>. Compare as árvores das Figuras <a class="reference internal" href="#fig-sgbd-indexes-arvores-binarias-pesquisa"><span class="std std-numref">2.33</span></a> e <a class="reference internal" href="#fig-sgbd-indexes-arvore-binaria-desbalanceada"><span class="std std-numref">2.34</span></a>. As duas árvores possuem 15 elementos com os mesmos valores de chave. No entanto, a árvore da <a class="reference internal" href="#fig-sgbd-indexes-arvore-binaria-desbalanceada"><span class="std std-numref">Figura 2.34</span></a> é considerada <strong>desbalanceada</strong> pois as folhas estão presentes em níveis muito diversos da árvore. Um dos efeitos do desbalanceamento é produzir uma estrutura mais profunda e sem a garantia de que o caminho até todas as folhas tenham o mesmo comprimento, isto é, o mesmo número de <em>nós</em>. Veja o exemplo do <em>nó folha</em> com chave 90 que aparece no <em>nível 3</em> e o <em>nó folha</em> com chave 65 que aparece no <em>nível 6</em>.</p>
<figure class="align-center align-default" id="fig-sgbd-indexes-arvore-binaria-desbalanceada">
<a class="reference internal image-reference" href="../_images/arvore-binaria-desbalanceada.png"><img alt="Árvore Binária de Pesquisa desbalanceada" src="../_images/arvore-binaria-desbalanceada.png" style="width: 75%;" /></a>
<figcaption>
<p><span class="caption-number">Figura 2.34 - </span><span class="caption-text">Árvore Binária de Pesquisa desbalanceada.</span><a class="headerlink" href="#fig-sgbd-indexes-arvore-binaria-desbalanceada" title="Link Permanente para essa imagem"></a></p>
</figcaption>
</figure>
<p>​
É provado na literatura, que as árvores binárias de pesquisa criadas com inserções e remoções aleatórias tendem a produzir uma árvore de altura <span class="math notranslate nohighlight">\(O(\log_2n)\)</span> <span id="id3">[<a class="reference internal" href="../referencias.html#id2" title="Alfred V. Aho, Jeffrey D. Ullman, and John E. Hopcroft. Data Structures and Algorithms. Addisson-Wesley, 1 edition, 1983.">1</a>]</span>. No entanto, para que isso seja uma garantia de fato, foram desenvolvidos vários métodos para manter uma árvore balanceada à medida que as operações de inserção e remoção são realizadas. As árvores binárias conhecidas por AVL​, Red-Black​ (árvores rubro-negras) e Splay-trees (ou zig-zag)​ são exemplos de árvores binárias de pesquisa balanceadas. Desta forma, as operações de busca, inserção e remoção são garantidamente realizadas em tempo logaritmico, ou seja, <span class="math notranslate nohighlight">\(O(\log_2n)\)</span>.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>De tudo que foi exposto acima, podemos concluir que a complexidade de realizar uma busca em uma árvore binária de pesquisa depende da altura <span class="math notranslate nohighlight">\(h\)</span> dessa árvore. Logo, se a árvore binária de pesquisa for balanceada e possuir <span class="math notranslate nohighlight">\(n\)</span> nós (ou elementos), a busca terá complexidade da ordem de​ <span class="math notranslate nohighlight">\(O(\log_2n)\)</span> pois <span class="math notranslate nohighlight">\(h = \log_2(n + 1) - 1\)</span>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>As árvores são uma das estruturas de dados mais versáteis na computação, com ampla aplicação nos SGBDs e nas aplicações do dia-a-dia.</p>
</div>
</section>
<section id="arvores-b">
<h3><span class="section-number">2.23.2.3. </span>Árvores-B<a class="headerlink" href="#arvores-b" title="Link permanente para este cabeçalho"></a></h3>
<p>As árvores binárias são usadas, principalmente, em problemas que cabem completamente em memória principal (RAM). No caso de grandes bancos de dados a memória principal pode não ser suficiente para armazenar todos os <em>nós</em> da árvore que compõe o índice. Por isso, é comum armazenar a estrutura de árvore (ou índice) em disco.​ Nesse caso, devemos utilizar uma representação que procure minimizar o acesso a disco para recuperação dos elementos da árvore.</p>
<p>A <a class="reference internal" href="#fig-sgbd-indexes-b-plus-tree"><span class="std std-numref">Figura 2.36</span></a> ilustra o esquema da estrutura de uma Árvore-B, que é uma árvore <strong>multivias</strong> (<strong>multiway tree</strong>), isto é, uma árvore cujos os <em>nós</em> podem ter <strong>mais de dois descendentes</strong>.</p>
<figure class="align-center align-default" id="fig-sgbd-indexes-b-tree">
<a class="reference internal image-reference" href="../_images/b-tree.png"><img alt="Esquema de uma Árvore-B" src="../_images/b-tree.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-number">Figura 2.35 - </span><span class="caption-text">Esquema de uma Árvore-B.</span><a class="headerlink" href="#fig-sgbd-indexes-b-tree" title="Link Permanente para essa imagem"></a></p>
</figcaption>
</figure>
<p>Numa Árvore-B, cada <em>nó</em> pode conter <span class="math notranslate nohighlight">\(k\)</span> descendentes e <span class="math notranslate nohighlight">\(k - 1\)</span> chaves, com <span class="math notranslate nohighlight">\(m ​\leqslant k ​\leqslant M\)</span>, onde, em geral, adota-se <span class="math notranslate nohighlight">\(m = \lceil \frac{M}{2}  \rceil\)</span>. O fator <span class="math notranslate nohighlight">\(M\)</span> é conhecido como <strong>ordem da árvore</strong> ou <strong>fator de ramificação</strong> (<strong>branch factor</strong> ou <strong>fanout</strong>). Apenas o <em>nó raiz</em> pode conter um número menor do que <span class="math notranslate nohighlight">\(m - 1\)</span> chaves. Se a árvore possuir mais de um nível de profundidade, a raiz deve ter pelo menos 2 filhos. Todas as folhas da árvore estão no mesmo nível, isto é, trata-se de uma <strong>árvore balanceada</strong>. As chaves em cada nó devem encontrar-se em ordem crescente (ou decrescente), para permitir o uso de pesquisa binária nos valores armazendados no <em>nó</em>.</p>
<p>Os <em>nós</em> também são conhecidos como <strong>páginas</strong> pois comportam várias chaves além de valores que permitem estabelecer as ligações entre as <em>páginas</em>. Chamaremos de <strong>ponteiros</strong> os valores que permitem estabelecer as ligações entre os <em>nós</em> (arcos pretos). Também podemos ter associado a cada chave algum dado que ajude a localizar o objeto indexado. No nosso exemplo, estamos considerando que o índice fornece o endereço da linha associada à chave e, por isso, utilizamos o termo <strong>TID</strong> (<em>tuple identifier</em>) para indicar a informação de um indentificador da linha referenciada pelo índice no respectivo valor de chave.</p>
<p>Nos <em>nós internos</em>, o <em>i-th</em> ponteiro leva à sub-árvore com valores inferiores à <em>i-th</em> chave, com <span class="math notranslate nohighlight">\(1 \leqslant i ​\leqslant M\)</span>. O último ponteiro em cada <em>nó interno</em> leva à sub-árvore com valores maiores ao último valor de chave nessa <em>página</em>. Por exemplo, o círculo preto com o arco saindo à esquerda da chave de valor 11 no <em>nó raiz</em>, é um ponteiro para a raiz da sub-árvore contendo todos os valores menores do que 11. De maneira similar, o círculo preto com o arco saindo à esquerda da chave de valor 23 no <em>na raiz</em>, é um ponteiro para a sub-árvore contendo todos os valores maiores do que 11 e menores que 23. Desta forma, cada uma das chaves ajuda a definir um intervalo de valores indexados que podem ser encontrados nas sub-árvores.</p>
<p>Para exemplificar o uso dessa estrutura na localização de uma chave, vamos considerar uma busca pela chave de valor 41. Partindo do <em>nó raiz</em>, verificamos que a chave procurada é maior que 23 e menor que 43. Nesse caso, tomamos a direção da sub-árvore indicada pelo ponteiro à esquerda do valor 43, chegando à <em>página</em> com as chaves <span class="math notranslate nohighlight">\(\{29, 31, 37, 41\}\)</span>. Como essa <em>página</em> é uma folha e ela contém a chave procurada, podemos reportar o identificador da linha associada à chave 41.</p>
<p>Uma Árvore-B será mais profunda (ou terá a maior altura) quando todo <em>nó</em> possuir o menor fator de ramificação, isto é, quando <span class="math notranslate nohighlight">\(m = \lceil \frac{M}{2}  \rceil\)</span>. Neste caso, teríamos em cada <em>página</em> a seguinte quantidade de chaves:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{nível 0: } 1\text{ chave}\\
\text{nível 1: } 2(m-1)\text{ chaves}\\
\text{nível 2: } 2m(m-1)\text{ chaves}\\
\text{nível 3: } 2m^2(m-1)\text{ chaves}\\
\dots\\
\text{nível h: } 2m^{h-1}(m-1)\text{ chaves}\\\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Note que aqui estamos adotando a altura como o número de arestas no caminho mais comprido da <em>raiz</em> até a <em>folha</em>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Podemos ler a sequência acima da seguinte forma:</p>
<ul class="open">
<li><p>No nível 0, teremos uma <span class="math notranslate nohighlight">\(1\)</span> chave e, logo essa <em>página</em> dará origem a outras duas <em>páginas</em> no próximo nível (nível 1), cada uma com <span class="math notranslate nohighlight">\(m-1\)</span> chaves.</p></li>
<li><p>No nível 1, cada uma das <em>páginas</em> vai dar origem a outras <span class="math notranslate nohighlight">\(m\)</span> <em>páginas</em>, de forma que teremos <span class="math notranslate nohighlight">\(2m\)</span> <em>páginas</em> no próximo nível (nível 2), cada um com <span class="math notranslate nohighlight">\(m-1\)</span> chaves.</p></li>
<li><p>e assim, sucessivamente até o último nível da árvore denominado <span class="math notranslate nohighlight">\(h\)</span> (altura da árvore).​</p></li>
</ul>
</div>
<p>Somando todas as chaves, teremos:​</p>
<div class="math notranslate nohighlight">
\[\begin{split}1 + 2(m-1) + 2m(m-1) + 2m^2(m-1) + \dots + 2m^{h-1}(m-1)\\
1 + 2(m-1)(1 + m + m^2 + \dots + m^{h-1})\\
1 + 2(m-1)(m^0 + m^1 + m^2 + \dots + m^{h-1})\\
1 + 2(m-1) \sum_{i=0}^{h-1} m^i = 1 + 2(m-1) \left( \frac{1-m^h}{1-m} \right) = 2m^h - 1\end{split}\]</div>
<p>Isso significa que o número de chaves <span class="math notranslate nohighlight">\(n\)</span> será: <span class="math notranslate nohighlight">\(n \geq 2m^h-1\)</span>, ou seja:</p>
<div class="math notranslate nohighlight">
\[\frac{n+1}{2} \geq m^h\]</div>
<div class="math notranslate nohighlight">
\[\log_m \left( \frac{n+1}{2} \right) \geq \log_m m^h\]</div>
<div class="math notranslate nohighlight">
\[\therefore h \leqslant \log_m \left( \frac{n+1}{2} \right)\]</div>
<p>A partir dessa equação, podemos assumir que para uma Árvore-B de ordem <span class="math notranslate nohighlight">\(M = 200\)</span>, onde iremos manipular <span class="math notranslate nohighlight">\(2.000.000\)</span> chaves, se tomarmos <span class="math notranslate nohighlight">\(m = 100\)</span>, teremos: <span class="math notranslate nohighlight">\(h \leqslant 3\)</span>. Portanto, encontrar uma chave nessa árvore exige, no pior caso, avaliarmos chaves em 4 <em>páginas</em>.​</p>
<p>Podemos, portanto, concluir que para <span class="math notranslate nohighlight">\(M\)</span> suficientemente grande, <span class="math notranslate nohighlight">\(h\)</span> será pequeno, mesmo que exista um grande número de chaves na árvore. Obviamente, que deve existir um balanceamento da <strong>ordem da árvore</strong> com a <strong>capacidade de uma página do disco</strong>, que é a unidade manipulada nas operações de leitura e gravação em disco.​ O PostgreSQL, por exemplo, utiliza por padrão <strong>blocos</strong> de 8.192 bytes (ou 8 kB). Se adotarmos que as chaves sejam formadas por um número inteiro de 4 bytes e que os ponteiros de ligação entre as <em>páginas</em> sejam formados por inteiros de 4 bytes, uma página de 8.192 bytes seria capaz de comportar <em>páginas</em> de uma Árvore-B de ordem <span class="math notranslate nohighlight">\(M = 1024\)</span>, isto é, cada <em>página</em> seria capaz de ramificar em até 1024 descendentes e comportar 1023 chaves (números inteiros de 4 bytes). Obviamente que aqui estamos desconsiderando o espaço necessário para representar o dado de associação com a linha tabela.</p>
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>Na Internet encontram-se disponíveis vários visualizadores online capazes de demonstrar a criação de Árvores-B. O site de David Galles apresenta um visualizador interativo bastante interessante para <a class="reference external" href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">Árvores-B</a>.</p>
</div>
</section>
<section id="id4">
<h3><span class="section-number">2.23.2.4. </span>Árvores-B<sup>+</sup><a class="headerlink" href="#id4" title="Link permanente para este cabeçalho"></a></h3>
<p>A estrutura de Árvore-B apresentada na seção anterior fornece a capacidade de realizar operações de busca, inserção e remoção em tempo logarítmico, uma vez que <span class="math notranslate nohighlight">\(h \leqslant \log_m \left( \frac{n+1}{2} \right)\)</span>. Portanto, essa estrutura fornece a capacidade de uma acesso aleatório a um dado item com muita eficiência. No entanto, os sistemas de bancos de dados devem fornecer a capacidade de recuperar registros com padrões de acesso que misturam o acesso aleatório com o sequencial. Isto ocorre quando uma busca envolve um intervalo de valores. Nesse caso, usar uma Árvore-B como a da seção anterior, poderá fazer com que seja necessária uma travessia por vários nós internos para recuperar todas as chaves dentro do intervalo pesquisado.</p>
<p>Existem diversas <strong>variantes</strong> da estrutura de Árvore-B apresentada na seção anterior, cada uma projetada para responder algum padrão de acesso ou utilizar uma estrutura mais adequada a certos conjuntos de dados e operações. A forma mais comum, e mais largamente empregada pelos SGBDs atuais, tanto os baseados em software livre quanto os comerciais, é a representação do índice através de uma Árvore-B<sup>+</sup>.​ A <a class="reference internal" href="#fig-sgbd-indexes-b-plus-tree"><span class="std std-numref">Figura 2.36</span></a> ilustra o esquema da estrutura de uma Árvore-B<sup>+</sup>.</p>
<figure class="align-center align-default" id="fig-sgbd-indexes-b-plus-tree">
<a class="reference internal image-reference" href="../_images/b-plus-tree.png"><img alt="Esquema de uma Árvore-B+" src="../_images/b-plus-tree.png" style="width: 100%;" /></a>
<figcaption>
<p><span class="caption-number">Figura 2.36 - </span><span class="caption-text">Esquema de uma Árvore-B<sup>+</sup>.</span><a class="headerlink" href="#fig-sgbd-indexes-b-plus-tree" title="Link Permanente para essa imagem"></a></p>
</figcaption>
</figure>
<p>A estrutura dessa árvore é muito semelhante à da Árvore-B mostrada na seção anterior, com a diferença de que nessa estrutura, todas as chaves encontram-se nas folhas e algumas chaves são usadas como guias dos <em>nós internos​</em>.</p>
<p>Nos <em>nós internos</em>, o <em>i-th</em> ponteiro leva à sub-árvore com valores inferiores à <em>i-th</em> chave, com <span class="math notranslate nohighlight">\(1 \leqslant i ​\leqslant M\)</span>. O último ponteiro em cada <em>nó interno</em> leva à sub-árvore com valores maiores ou iguais ao último valor de chave nessa <em>página</em>. Por exemplo, o círculo preto com o arco saindo à esquerda da chave de valor 23 no <em>nó raiz</em>, é um ponteiro para a raiz da sub-árvore contendo todos os valores menores do que 23. De maneira similar, o círculo preto com o arco saindo à esquerda da chave de valor 43 no <em>nó interno</em>, é um ponteiro para a sub-árvore contendo todos os valores maiores ou iguais a 37 e menores que 43. Desta forma, cada uma das chaves ajuda a definir um intervalo de valores indexados pelas sub-árvores.</p>
<p>A estrutura das <em>páginas</em> dos <em>nós folhas</em> possui, além das chaves, ponteiros para os objetos indexados relacionados ao valor de chave. Esse valor é indicado pelos arcos azuis. No nosso exemplo, estamos considerando que o índice fornece o endereço da linha associada à chave e, por isso, utilizamos o termo <strong>TID</strong> (<em>tuple identifier</em>) para indicar a informação de um indentificador da linha referenciada pelo índice no respectivo valor de chave. Outra diferença dessa estrutura é que o último elemento das <em>páginas</em> dos <em>nós folhas</em> possui uma ligação para a <em>página</em> contendo os valores de chave na sequência, indicado na figura por uma seta em vermelho. Essa ligação entre as <em>páginas</em> no nível das folhas pemite utilizar o índice da Árvore-B<sup>+</sup> para recuperação de intervalos.</p>
<p>Para exemplificar o uso dessa estrutura na localização de um objeto indexado por ela, vamos considerar uma busca pela chave de valor 41. Partindo do <em>nó raiz</em>, verificamos que a chave procurada é maior que a única chave presente nesse nó, que é 23. Nesse caso, tomamos a direção da sub-árvore com valores maiores ou iguais a 23, chegando à <em>página</em> com as chaves <span class="math notranslate nohighlight">\(\{37, 43\}\)</span>. Como a chave procurada é maior ou igual a 37 e menor que 43, seguimos a ligação para <em>página</em> contendo as chaves <span class="math notranslate nohighlight">\(\{37, 41\}\)</span>. Como essa <em>página</em> é uma folha e ela contém a chave procurada, podemos reportar o identificador da linha associada à chave 41.</p>
<p>Essa estrutura ainda permite responder <strong>consultas de intervalos unidimensionais</strong>. Considere a busca pelas linhas com chaves de valores maiores que 29 e menores que 43. Assim como no exemplo anterior, a busca é iniciada pelo <em>nó raiz</em>. Como o menor valor do intervalo procurado é maior ou igual à chave na <em>raiz</em>, tomamos o caminho da <em>página</em> com as chaves <span class="math notranslate nohighlight">\(\{37, 41\}\)</span>. Como a chave procurada é menor do que a chave 37, seguimos o caminho da <em>página</em> na folha da árvore contendo as chaves <span class="math notranslate nohighlight">\(\{23, 29, 31\}\)</span>. A partir dessa <em>página</em>, podemos varrer sequencialmente as <em>páginas</em> no nível das folhas até encontrar um valor de chave maior ou igual a 43. As ligações entre as <em>páginas</em> no nível da folha, mostradas em vermelho, possibilitam esse acesso sequencial de maneira eficiente.</p>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>As Árvores-B assim como algumas de suas variantes foram introduzidas em 1972 por Bayer e Mccreight <span id="id5">[<a class="reference internal" href="../referencias.html#id4" title="R. Bayer and E. M. Mccreight. Organization and maintenance of large ordered indexes. Acta Inf., 1(3):173–189, sep 1972. doi:10.1007/BF00288683.">3</a>]</span>. Uma boa revisão da literatura sobre sobre Árvores-B e suas variantes pode ser encontrada em <span id="id6">[<a class="reference internal" href="../referencias.html#id10" title="Douglas Comer. The ubiquitous b-tree. ACM Computing Surveys, 11(2):121–137, jun 1979. doi:10.1145/356770.356776.">10</a>]</span>.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>Na Internet encontram-se disponíveis vários visualizadores online capazes de demonstrar a criação de Árvores-B<sup>+</sup>. O site de David Galles apresenta um visualizador interativo bastante interessante para <a class="reference external" href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">Árvores-B</a>.</p>
</div>
</section>
</section>
<section id="indexacao-no-postgresql">
<h2><span class="section-number">2.23.3. </span>Indexação no PostgreSQL<a class="headerlink" href="#indexacao-no-postgresql" title="Link permanente para este cabeçalho"></a></h2>
<p>O PostgreSQL fornece diversos mecanismos para indexação. O emprego de cada um deles depende do tipo de dado e das operações desejadas nas consultas. Os mecanismos fornecidos são:</p>
<ul class="open">
<li><p><strong>B-Tree:</strong> Pode ser empregado nas consultas que envolvem comparações de igualdade ou de intervalo unidimensional. Quando uma coluna é indexada com este tipo de índice e ela aparece na consulta junto com um dos operadores <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code> ou <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, o <strong>query planner</strong> do PostgreSQL irá considerar o uso do índice no processamento da consulta.</p></li>
<li><p><strong>Hash:</strong> É usado para indexar conjuntos de dados que são pesquisados apenas pela igualdade. Logo, quando uma coluna é indexada com este tipo de índice e ela aparece na consulta junto com o operador <code class="docutils literal notranslate"><span class="pre">=</span></code>, o <em>query planner</em> do PostgreSQL irá considerar o uso do índice no processamento da consulta. A aplicação desse tipo de índice é muito específica e, geralmente, pouco utilizado na prática, principalmente pelo fato de suportar apenas um tipo de consulta: <em>por igualdade de chave</em>.</p></li>
<li><p><strong>GiST (Generalized Search Tree):</strong> Trata-se na verdade de um <em>framework</em> para criação de índices <span id="id7">[<a class="reference internal" href="../referencias.html#id19" title="Joseph M. Hellerstein, Jeffrey F. Naughton, and Avi Pfeffer. Generalized search trees for database systems. In Umeshwar Dayal, Peter M. D. Gray, and Shojiro Nishio, editors, VLDB'95, Proceedings of 21th International Conference on Very Large Data Bases, September 11-15, 1995, Zurich, Switzerland, 562–573. Morgan Kaufmann, 1995. URL: http://www.vldb.org/conf/1995/P562.PDF.">17</a>]</span>. É uma peça fundamental nos componentes de extensibilidade do PostgreSQL para possibilitar a criação de tipos de dados mais complexos que possam ser indexados. A extensão geoespacial PostGIS, que iremos abordar mais adiante, fornece tipos geométricos e matriciais com suporte a <strong>indexação espacial</strong> do tipo <code class="docutils literal notranslate"><span class="pre">R-Tree</span></code>. Cada implementação de índice baseada no GiST fornece seu conjunto de operadores de indexação. Por exemplo, colunas baseadas nos tipos geométricos do PostGIS, quando indexadas com a <code class="docutils literal notranslate"><span class="pre">R-tree</span></code> bi-dimensional definida sobre o GiST, ao serem usadas em consultas envolvendo restrições com os seguintes operadores: <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">~=</span></code>, <code class="docutils literal notranslate"><span class="pre">~</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;&lt;|</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;&lt;|</span></code>, <code class="docutils literal notranslate"><span class="pre">|&gt;&gt;</span></code> e <code class="docutils literal notranslate"><span class="pre">|&amp;&gt;</span></code>, faz com que o <em>query planner</em> considere o uso desses índices no processamento das consultas.</p></li>
<li><p><strong>SP-GiST (Space-Partitioned GiST)</strong>: Assim com o mecanismo GiST, fornece um <em>framework</em> para criação de índices baseados em técnicas de partição espacial, como <code class="docutils literal notranslate"><span class="pre">quad-trees</span></code> e <code class="docutils literal notranslate"><span class="pre">k-d</span> <span class="pre">trees</span></code> <span id="id8">[<a class="reference internal" href="../referencias.html#id3" title="Walid G. Aref and Ihab F. Ilyas. Sp-gist: an extensible database index for supporting space partitioning trees. J. Intell. Inf. Syst., 17(2-3):215–240, 2001. doi:10.1023/A:1012809914301.">2</a>]</span>, <span id="id9">[<a class="reference internal" href="../referencias.html#id15" title="Mohamed Y. Eltabakh, Ramy Eltarras, and Walid G. Aref. Space-partitioning trees in postgresql: realization and performance. In Ling Liu, Andreas Reuter, Kyu-Young Whang, and Jianjun Zhang, editors, Proceedings of the 22nd International Conference on Data Engineering, ICDE 2006, 3-8 April 2006, Atlanta, GA, USA, 100. IEEE Computer Society, 2006. doi:10.1109/ICDE.2006.146.">12</a>]</span>. Voltaremos a discutir mais sobre esse tipo de índice quando falarmos de indexação espacial.</p></li>
<li><p><strong>GIN (Generalized Inverted Indexes):</strong> Usado em dados como os documentos JSON e os tipos <code class="docutils literal notranslate"><span class="pre">array</span></code> do PostgreSQL. Voltaremos a discutir mais sobre esse tipo de índice ao falarmos sobre o tipo <code class="docutils literal notranslate"><span class="pre">jsonb</span></code> do PostgreSQL.</p></li>
<li><p><strong>BRIN (Block Range Indexes):</strong> Esse tipo de índice é baseado na estratégia de ter resumos sobre os valores armazenados em intervalos de blocos físicos consecutivos de uma tabela. Daremos mais detalhes sobre esse método mais adiante.</p></li>
</ul>
<section id="criacao-de-indices">
<h3><span class="section-number">2.23.3.1. </span>Criação de Índices<a class="headerlink" href="#criacao-de-indices" title="Link permanente para este cabeçalho"></a></h3>
<p>Quando definimos que uma coluna é chave primária, automaticamente o PostgreSQL realiza a criação de um índice, geralmente, baseado em uma <code class="docutils literal notranslate"><span class="pre">B-Tree</span></code>, para a coluna em questão. Na tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code> podemos ver que existe um índice denominado <code class="docutils literal notranslate"><span class="pre">municipio_pkey</span></code>:</p>
<div class="highlight-psql notranslate"><div class="highlight"><pre><span></span><span class="gp">bdgeo=#</span><span class="w"> </span><span class="kp">\d</span><span class="w"> </span><span class="ss">municipio_pkey</span>
</pre></div>
</div>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>       Index &quot;public.municipio_pkey&quot;
 Column |     Type     | Key? | Definition
--------+--------------+------+------------
 id     | character(7) | yes  | id
primary key, btree, for table &quot;public.municipio&quot;
</pre></div>
</div>
<p>A sintaxe básica para criação de índices é a seguinte:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>CREATE [UNIQUE] INDEX [CONCURRENTLY] nome-indice

    ON nome-tabela [USING nome-método]​

    ( {nome-coluna|(expressão)} [opclass] [ASC|DESC]​ [NULLS {FIRST|LAST}] [, ...] )​

    [ INCLUDE ( nome-coluna [, ...] ) ]

    [ WITH (storage_parameter [= value] [, ...]) ]​

    [ TABLESPACE tablespace ]​

    [ WHERE predicado ]
</pre></div>
</div>
<p>Vamos criar um índice na tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code> sobre a coluna <code class="docutils literal notranslate"><span class="pre">nome</span></code>:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">municipio_nome_idx</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">municipio</span><span class="w"> </span><span class="p">(</span><span class="n">nome</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Em seguida, vamos atualizar as estatísticas sobre a tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code>:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">ANALYZE</span><span class="w"> </span><span class="n">municipio</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Agora, vamos verificar novamente como a consulta à tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code> envolvendo um predicado usando a coluna <code class="docutils literal notranslate"><span class="pre">nome</span></code> é executada:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="p">(</span><span class="k">ANALYZE</span><span class="w"> </span><span class="k">TRUE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">municipio</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">nome</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Araxá&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>                                                          QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------
 Index Scan using municipio_nome_idx on municipio  (cost=0.28..8.30 rows=1 width=21) (actual time=0.073..0.076 rows=1 loops=1)
   Index Cond: ((nome)::text = &#39;Araxá&#39;::text)
 Planning Time: 0.446 ms
 Execution Time: 0.108 ms
</pre></div>
</div>
<p>Repare que agora, o PostgreSQL utiliza um acesso indexado através do novo índice <code class="docutils literal notranslate"><span class="pre">municipio_nome_idx</span></code>, que fornece um custo menor de execução do que a versão com busca sequencial.</p>
</section>
<section id="remocao-de-indices">
<h3><span class="section-number">2.23.3.2. </span>Remoção de Índices<a class="headerlink" href="#remocao-de-indices" title="Link permanente para este cabeçalho"></a></h3>
<p>Um índice pode ser removido através do comado <code class="docutils literal notranslate"><span class="pre">DROP</span> <span class="pre">INDEX</span></code>, que possui a seguinte sintaxe:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">DROP</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">nome</span><span class="o">-</span><span class="n">indice</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="consideracoes-sobre-criacao-e-uso-de-indices">
<h3><span class="section-number">2.23.3.3. </span>Considerações Sobre Criação e Uso de Índices<a class="headerlink" href="#consideracoes-sobre-criacao-e-uso-de-indices" title="Link permanente para este cabeçalho"></a></h3>
<p>Os índices são essenciais para que o SGBD forneça o mecanismo de restrição de chave primária. Isso é tão forte, que no PostgreSQL ao definir uma ou mais colunas  como chave primária, um índice é automaticamente criado. O nome desse índice é dado automaticamente pelo PostgreSQL e segue o seguinte padrão: <code class="docutils literal notranslate"><span class="pre">&lt;nome-tabela&gt;_pkey</span></code>.</p>
<p>A restrição de chave única (<code class="docutils literal notranslate"><span class="pre">UNIQUE</span></code>) também é implementada com o uso de um índice que garanta que os valores de chave não sejam duplicados. O nome desse índice, quando dado automaticamente pelo PostgreSQL, segue o seguinte padrão: <code class="docutils literal notranslate"><span class="pre">&lt;nome-tabela&gt;_&lt;nome-coluna&gt;[_&lt;nome-coluna&gt;]_key</span></code>. Considere a tabela <code class="docutils literal notranslate"><span class="pre">professor</span></code>, um índice de chave única poderia ser criado sobre a coluna <code class="docutils literal notranslate"><span class="pre">nome</span></code> da seguinte forma:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">UNIQUE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">professor_nome_key</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">professor</span><span class="w"> </span><span class="p">(</span><span class="n">nome</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>A criação de um índice sobre uma ou mais colunas em uma tabela com dezenas de milhares de registros é uma operação relativamente rápida. Para tabelas com milhões de linhas, esse tempo pode ser um pouco maior e depende do tipo de índice a ser criado (B-tree ou GiST R-tree). Além disso, pode ser necessário alterar o parâmetro de configuração <code class="docutils literal notranslate"><span class="pre">maintenance_work_mem</span></code> do servidor PostgreSQL, para aumentar a quantidade de memória usada durante as operações de criação de índices, e assim acelerar a sua criação.</p>
<p>Índices podem ser construídos e removidos a qualquer momento.​ Uma vez criado o índice, não é necessário mais intervenções pois ele é atualizado toda vez que a tabela é modificada.​ Os índices são automaticamente atualizados durante as operações de inserção, atualização e remoção das linhas, de maneira que sua estrutura não se degrada com o tempo.</p>
<p>Além das consultas, um índice pode acelerar as operações de atualização e remoção de linhas quando estas estejam utilizando um predicado na cláusula <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> que possa se beneficiar dessa indexação.</p>
<p>É muito comum ter tabelas com vários índices definidos sobre os campos mais utilizados em pesquisas. Apesar de ser possível a criação de diversos índices em uma mesma tabela, devemos tomar cuidado para que o excesso de índices não degrade o desempenho do sistema. Ou seja, a criação de índices deve ser feita apenas se estritamente necessária pois a manutenção da estrutura do índice acarreta em mais operações para o SGBD, podendo ter impacto direto nas operações de inserção, atualização e remoção de linhas, além de ocupar um espaço extra de armazenamento em disco. Por isso, devemos evitar a criação de índices que não sejam usados em consultas ou comandos de atualização mais frequentes.</p>
<p>Um índice pode ser criado sobre várias colunas. Chamamos este tipo de índice de <strong>índice multicoluna</strong> (<strong>multicolumn index</strong>). Na tabela <code class="docutils literal notranslate"><span class="pre">estudante_disciplina</span></code>, o índice definido pela chave primária, nomeado <code class="docutils literal notranslate"><span class="pre">estudante_disciplina_pkey</span></code>, é formado pelos valores dos campos <code class="docutils literal notranslate"><span class="pre">matricula</span></code> e <code class="docutils literal notranslate"><span class="pre">codigo</span></code>, como mostrado abaixo:</p>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Index &quot;public.estudante_disciplina_pkey&quot;
  Column   |  Type   | Key? | Definition
-----------+---------+------+------------
 matricula | integer | yes  | matricula
 codigo    | integer | yes  | codigo
primary key, btree, for table &quot;public.estudante_disciplina&quot;
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Esse tipo de índice é útil quando as consultas utilizam o campo <code class="docutils literal notranslate"><span class="pre">matricula</span></code>, isto é, o primeiro campo das chaves do índice. Faremos um exercício com índices multicoluna na <a class="reference internal" href="#cap-sgbd-indexes-exercicios"><span class="std std-numref">Seção 2.23.5 - Exercícios</span></a>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Os comandos e operações que podem se beneficiar da existência de um índice são:​</p>
<ul class="open">
<li><p><code class="docutils literal notranslate"><span class="pre">SELECT</span></code>, <code class="docutils literal notranslate"><span class="pre">INSERT</span></code>, <code class="docutils literal notranslate"><span class="pre">UPDATE</span></code>, <code class="docutils literal notranslate"><span class="pre">DELETE</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LIMIT</span></code></p></li>
<li><p>Junção de tabelas​</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Um índice tipo B-tree será considerado pelo <strong>query planner</strong> quando a coluna(s) indexada(s) envolver(em) comparações usando os seguintes operadores: <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;=</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">BETWEEN</span></code>, <code class="docutils literal notranslate"><span class="pre">IN</span></code> e <code class="docutils literal notranslate"><span class="pre">LIKE</span></code>. No caso do <code class="docutils literal notranslate"><span class="pre">LIKE</span></code>, os índice são usados apenas se o carácter curinga estiver no fim do padrão procurado.​</p>
</div>
</section>
<section id="indices-sobre-expressoes-ou-indices-funcionais">
<h3><span class="section-number">2.23.3.4. </span>Índices sobre Expressões ou Índices Funcionais<a class="headerlink" href="#indices-sobre-expressoes-ou-indices-funcionais" title="Link permanente para este cabeçalho"></a></h3>
<p>Muitas vezes realizamos consultas que envolvem a aplicação de uma expressão sobre um dos campos da tabela, como por exemplo:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">municipio</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="k">lower</span><span class="p">(</span><span class="n">nome</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;araxá&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Nesta consulta aquele índice definido sobre a coluna <code class="docutils literal notranslate"><span class="pre">nome</span></code> da tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code> não será usado, como indicado abaixo:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="p">(</span><span class="k">ANALYZE</span><span class="w"> </span><span class="k">TRUE</span><span class="p">)</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">municipio</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">lower</span><span class="p">(</span><span class="n">nome</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;araxá&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>                                              QUERY PLAN
-------------------------------------------------------------------------------------------------------
 Seq Scan on municipio  (cost=0.00..119.55 rows=28 width=21) (actual time=3.015..7.202 rows=1 loops=1)
   Filter: (lower((nome)::text) = &#39;araxá&#39;::text)
   Rows Removed by Filter: 5569
 Planning Time: 0.100 ms
 Execution Time: 7.228 ms
</pre></div>
</div>
<p>O fato de usarmos uma expressão como <code class="docutils literal notranslate"><span class="pre">lower(nome)</span></code> fará com que os valores usados para criação do índice não possam ser diretamente utilizados. Desta forma, o PostgreSQL fornece um mecanismo denominado de <strong>índices sobre expressões</strong> ou <strong>índices funcionais​</strong>. Se sempre formos usar a função <code class="docutils literal notranslate"><span class="pre">lower</span></code> nas consultas, então deveríamos ter criado o índice com a seguinte definição:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span>CREATE INDEX municipio_lower_nome_idx ON municipio ( lower(nome) );​
</pre></div>
</div>
</section>
</section>
<section id="verificando-o-plano-de-execucao-de-uma-consulta-no-postgresql">
<h2><span class="section-number">2.23.4. </span>Verificando o Plano de Execução de uma Consulta no PostgreSQL<a class="headerlink" href="#verificando-o-plano-de-execucao-de-uma-consulta-no-postgresql" title="Link permanente para este cabeçalho"></a></h2>
<p>Um dos recursos de um bom SGBD é um componente denominado <strong>query planner</strong>, que é capaz de traçar vários <strong>planos de execução</strong> para uma consulta e escolher o melhor deles. Um <strong>plano de execução</strong> é representado por uma estrutura de dados do tipo árvore onde cada <em>nó</em> representa uma etapa do processamento da consulta. Desta forma, em uma plano é possível ter nós que representam tipos de buscas (sequenciais ou indexadas), etapas de ordenação, junção entre tabelas, agregação de valores, entre outros.</p>
<p>Como vimos no início deste captítulo, o comando <code class="docutils literal notranslate"><span class="pre">EXPLAIN</span></code> mostra o plano que será usado pelo PostgreSQL para realizar uma consulta. Sua sintaxe é a seguinte:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>EXPLAIN [ ( opção [, ...] ) ] comando-sql
</pre></div>
</div>
<p>onde, <code class="docutils literal notranslate"><span class="pre">opção</span></code> pode ser um dos seguintes parâmetros: <code class="docutils literal notranslate"><span class="pre">ANALYZE</span></code>, <code class="docutils literal notranslate"><span class="pre">BUFFERS</span></code>, <code class="docutils literal notranslate"><span class="pre">COSTS</span></code>, <code class="docutils literal notranslate"><span class="pre">FORMAT</span></code>, <code class="docutils literal notranslate"><span class="pre">SETTINGS</span></code>, <code class="docutils literal notranslate"><span class="pre">SUMMARY</span></code>, <code class="docutils literal notranslate"><span class="pre">TIMING</span></code>, <code class="docutils literal notranslate"><span class="pre">VERBOSE</span></code>, <code class="docutils literal notranslate"><span class="pre">WAL</span></code>. Com exceção do parâmetro <code class="docutils literal notranslate"><span class="pre">FORMAT</span></code>, todos demais podem ser definidos com os valores lógicos <code class="docutils literal notranslate"><span class="pre">TRUE</span></code> ou <code class="docutils literal notranslate"><span class="pre">FALSE</span></code>. No caso do parâmetro <code class="docutils literal notranslate"><span class="pre">FORMAT</span></code>, é possível escolher um valor entre: <code class="docutils literal notranslate"><span class="pre">TEXT</span></code>, <code class="docutils literal notranslate"><span class="pre">XML</span></code>, <code class="docutils literal notranslate"><span class="pre">JSON</span></code> ou <code class="docutils literal notranslate"><span class="pre">YAML</span></code>.</p>
<p>A saída do comando <code class="docutils literal notranslate"><span class="pre">EXPLAIN</span></code> descreve a árvore do plano de execução da consulta, de maneira a fornecer informações como:​</p>
<ul class="open">
<li><p>Tipo do <em>nó</em> do plano.</p></li>
<li><p>Estimativa do custo inicial (ex: etapa de ordenação) e total​, ambos medidos em relação ao custo de recuperação de uma unidade do disco.</p></li>
<li><p>Estimativa do número total de linhas na saída​.</p></li>
<li><p>Estimativa média do tamanho (em bytes) de uma linha da saída​.</p></li>
</ul>
<p>Para compreender melhor esse comando, vamos retomar o exemplo do início deste capítulo, com a seguinte consulta na tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code>:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">municipio</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">nome</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Araxá&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>O comando <code class="docutils literal notranslate"><span class="pre">EXPLAIN</span></code> sem a opção <code class="docutils literal notranslate"><span class="pre">ANALYZE</span></code>, simplesmente apresenta uma estimativa da execução da consulta:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">municipio</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">nome</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Araxá&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>                         QUERY PLAN
------------------------------------------------------------
 Seq Scan on municipio  (cost=0.00..105.62 rows=1 width=21)
   Filter: ((nome)::text = &#39;Araxá&#39;::text)
</pre></div>
</div>
<p>A saída acima mostra que o PostgreSQL irá realizar uma <strong>pesquisa sequencial</strong> (<code class="docutils literal notranslate"><span class="pre">Seq</span> <span class="pre">Scan</span></code>) pelas linhas da tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code>, sendo estimada apenas uma linha como resultado (<code class="docutils literal notranslate"><span class="pre">rows=1</span></code>). Esse comando apresenta dois custos estimados (<code class="docutils literal notranslate"><span class="pre">cost</span></code>), o primeiro, indica o custo para iniciar a consulta (<code class="docutils literal notranslate"><span class="pre">0.00</span></code>) e o segundo, o custo total (<code class="docutils literal notranslate"><span class="pre">105.62</span></code>). ​Esse custo é medido em relação à recuperação de uma unidade do disco. Para saber o número de páginas e o número de linhas da tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code>, podemos consultar a tabela do <strong>catálogo do sistema</strong> chamada <code class="docutils literal notranslate"><span class="pre">pg_class</span></code>:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">relpages</span><span class="p">,</span><span class="w"> </span><span class="n">reltuples</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">pg_class</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">relname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;municipio&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span> relpages | reltuples
----------+-----------
       36 |      5570
(1 row)
</pre></div>
</div>
<p>A saída acima indica que a tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code> econtra-se armazenada em 36 páginas do disco e possui 5.570 tuplas ou linhas. O custo total de <code class="docutils literal notranslate"><span class="pre">105.62</span></code> para execução da consulta pode ser deduzido considerando que o plano implica em recuperar as 36 páginas do disco, irá extrair as 5.570 linhas e irá aplicar o filtro de comparação uma vez em cada linha. Logo, podemos considerar a seguinte fórmula para esse plano:</p>
<div class="math notranslate nohighlight">
\[\begin{split}(\text{páginas disco lidas} \times \text{seq_page_cost}) + (\text{linhas analisadas} \times \text{cpu_tuple_cost}) + \\
(\text{número linhas aplicada o filtro} \times \text{cpu_operator_cost})\end{split}\]</div>
<p>Onde:</p>
<ul class="open">
<li><p><code class="docutils literal notranslate"><span class="pre">seq_page_cost</span></code>: Custo estimado de buscar uma página do disco. Por padrão é definido como <code class="docutils literal notranslate"><span class="pre">1.0</span></code>. No caso da tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code>, uma busca sequencial irá recuperar 36 páginas, como mostrado na consulta acima.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cpu_tuple_cost</span></code>: Custo estimado de processar cada linha durante a consulta. Por padrão é definido como <code class="docutils literal notranslate"><span class="pre">0.01</span></code>. Como a tabela possui 5.570 linhas, o custo unitário de <code class="docutils literal notranslate"><span class="pre">cpu_tuple_cost</span></code> será multiplicado pelo número de linhas.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cpu_operator_cost</span></code>: Custo estimado de cada chamada de operador ou função envolvidos na consulta durante sua execução. Por padrão é definido como <code class="docutils literal notranslate"><span class="pre">0.0025</span></code>. Na consulta em análise, esse custo está associado ao filtro da cláusula <code class="docutils literal notranslate"><span class="pre">WHERE</span></code> mostrado como <code class="docutils literal notranslate"><span class="pre">Filter:</span> <span class="pre">((nome)::text</span> <span class="pre">=</span> <span class="pre">'Araxá'::text)</span></code> na saída do comando <code class="docutils literal notranslate"><span class="pre">EXPLAIN</span></code>.</p></li>
</ul>
<p>Substituindo as constantes com seus valores <em>default</em> e o número de páginas e linhas processados, temos: <span class="math notranslate nohighlight">\((36 \times 1.0) + (5570 \times 0.01) + (5570 \times 0.0025) = 105.62\)</span>.</p>
<p>Para obter a estatística do tempo de execução, podemos adicionar a opção <code class="docutils literal notranslate"><span class="pre">ANALYZE</span></code> ao comando acima:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="p">(</span><span class="k">ANALYZE</span><span class="w"> </span><span class="k">TRUE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">municipio</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">nome</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Araxá&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>                                              QUERY PLAN
------------------------------------------------------------------------------------------------------
 Seq Scan on municipio  (cost=0.00..105.62 rows=1 width=21) (actual time=0.801..1.773 rows=1 loops=1)
   Filter: ((nome)::text = &#39;Araxá&#39;::text)
   Rows Removed by Filter: 5569
 Planning Time: 0.179 ms
 Execution Time: 1.804 ms
</pre></div>
</div>
<p>A opção <code class="docutils literal notranslate"><span class="pre">ANALYZE</span></code> faz com que a consulta seja de fato realizada. Desta forma, o tempo inicial e total são exibidos, em milisegundos. Esse comando também mostra o número total de execuções do <em>nó</em> do plano (<code class="docutils literal notranslate"><span class="pre">loops</span></code>). Além disso, essa saída apresenta o número de linhas descartadas após a aplicação do filtro (<code class="docutils literal notranslate"><span class="pre">5569</span></code>).</p>
<p>Se existir um índice na tabela <code class="docutils literal notranslate"><span class="pre">municipio</span></code> associado à coluna <code class="docutils literal notranslate"><span class="pre">nome</span></code>, o PostgreSQL poderá gerar um plano de execução diferente para essa consulta:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="p">(</span><span class="k">ANALYZE</span><span class="w"> </span><span class="k">TRUE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">municipio</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">nome</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Araxá&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>                                                          QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------
 Index Scan using municipio_nome_idx on municipio  (cost=0.28..8.30 rows=1 width=21) (actual time=0.073..0.076 rows=1 loops=1)
   Index Cond: ((nome)::text = &#39;Araxá&#39;::text)
 Planning Time: 0.446 ms
 Execution Time: 0.108 ms
</pre></div>
</div>
<p>Dessa vez, repare que o PostgreSQL utilizou uma estratégia diferente da busca sequencial, que é a <strong>busca indexada</strong> (<code class="docutils literal notranslate"><span class="pre">Index</span> <span class="pre">Scan</span></code>) utilizando o índice  <code class="docutils literal notranslate"><span class="pre">municipio_nome_idx</span></code>. Repare que os custos envolvidos na execução dessa consulta são bem menores que a da anterior e, consequentemente, o tempo de execução também é menor.</p>
<p>Como último exemplo, considere a consulta abaixo, que recupera a lista de disciplinas cursadas pelo estudante de nome <code class="docutils literal notranslate"><span class="pre">Claudio</span></code>:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="p">(</span><span class="k">ANALYZE</span><span class="w"> </span><span class="k">TRUE</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">estudante</span><span class="w"> </span><span class="k">INNER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">estudante_disciplina</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="p">(</span><span class="n">matricula</span><span class="p">)</span><span class="w"></span>
<span class="w">                            </span><span class="k">INNER</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">disciplina</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="p">(</span><span class="n">codigo</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="k">WHERE</span><span class="w"> </span><span class="n">estudante</span><span class="mf">.</span><span class="n">nome</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Claudio&#39;</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Saída:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span>                                                            QUERY PLAN
<span class="linenos"> 2</span>-----------------------------------------------------------------------------------------------------------------------------------
<span class="linenos"> 3</span> Nested Loop  (cost=18.19..20.79 rows=1 width=192) (actual time=0.088..0.115 rows=1 loops=1)
<span class="linenos"> 4</span>   -&gt;  Hash Join  (cost=18.04..19.96 rows=1 width=106) (actual time=0.066..0.091 rows=1 loops=1)
<span class="linenos"> 5</span>         Hash Cond: (estudante_disciplina.matricula = estudante.matricula)
<span class="linenos"> 6</span>         -&gt;  Seq Scan on estudante_disciplina  (cost=0.00..1.73 rows=73 width=12) (actual time=0.016..0.030 rows=73 loops=1)
<span class="linenos"> 7</span>         -&gt;  Hash  (cost=18.00..18.00 rows=3 width=98) (actual time=0.026..0.027 rows=1 loops=1)
<span class="linenos"> 8</span>               Buckets: 1024  Batches: 1  Memory Usage: 9kB
<span class="linenos"> 9</span>               -&gt;  Seq Scan on estudante  (cost=0.00..18.00 rows=3 width=98) (actual time=0.014..0.022 rows=1 loops=1)
<span class="linenos">10</span>                     Filter: ((nome)::text = &#39;Claudio&#39;::text)
<span class="linenos">11</span>                     Rows Removed by Filter: 36
<span class="linenos">12</span>   -&gt;  Index Scan using disciplina_pkey on disciplina  (cost=0.15..0.83 rows=1 width=90) (actual time=0.016..0.017 rows=1 loops=1)
<span class="linenos">13</span>         Index Cond: (codigo = estudante_disciplina.codigo)
<span class="linenos">14</span> Planning Time: 0.533 ms
<span class="linenos">15</span> Execution Time: 0.181 ms
<span class="linenos">16</span>(13 rows)
</pre></div>
</div>
</section>
<section id="exercicios">
<span id="cap-sgbd-indexes-exercicios"></span><h2><span class="section-number">2.23.5. </span>Exercícios<a class="headerlink" href="#exercicios" title="Link permanente para este cabeçalho"></a></h2>
<p><strong>Exercício 1.</strong> Proponha os índices a serem criados para as tabelas <code class="docutils literal notranslate"><span class="pre">populacao</span></code> e <code class="docutils literal notranslate"><span class="pre">homicidio</span></code> criados na <a class="reference internal" href="import-export.html#cap-sgbd-import-export-exercicios"><span class="std std-numref">Seção 2.22.3</span></a>.</p>
<p><strong>Exercício 2.</strong> Vamos criar uma tabela chamada <code class="docutils literal notranslate"><span class="pre">pts</span></code> com a seguinte definição:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">pts</span><span class="w"></span>
<span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">id</span><span class="w">     </span><span class="n">UUID</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">gen_random_uuid</span><span class="p">(),</span><span class="w"></span>
<span class="w">    </span><span class="n">x</span><span class="w">      </span><span class="n">DOUBLE</span><span class="w"> </span><span class="k">PRECISION</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">y</span><span class="w">      </span><span class="n">DOUBLE</span><span class="w"> </span><span class="k">PRECISION</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">word</span><span class="w">   </span><span class="nb">TEXT</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Em seguida, vamos inserir um conjunto sintético de dados nessa tabela:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">pts</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">(</span><span class="w"></span>
<span class="w">                    </span><span class="k">SELECT</span><span class="w"> </span><span class="mi">360</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">random</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">180</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="mi">180</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">random</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">90</span><span class="p">.</span><span class="mi">0</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"></span>
<span class="w">                           </span><span class="n">rpad</span><span class="p">(</span><span class="n">i</span><span class="p">::</span><span class="nb">text</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">word</span><span class="w"></span>
<span class="w">                      </span><span class="k">FROM</span><span class="w"> </span><span class="n">generate_series</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1000000</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">i</span><span class="w"></span>
<span class="w">                </span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Verifique como a seguinte consulta é realizada:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">ANALYZE</span><span class="w"></span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">      </span><span class="k">FROM</span><span class="w"> </span><span class="n">pts</span><span class="w"></span>
<span class="w">     </span><span class="k">WHERE</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">2.0</span><span class="w"></span>
<span class="w">       </span><span class="k">AND</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Resultado:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>                                                                     QUERY PLAN
-----------------------------------------------------------------------------------------------------------------------------------------------
 Gather  (cost=1000.00..531449.00 rows=750 width=64) (actual time=675.586..4164.905 rows=425 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   -&gt;  Parallel Seq Scan on pts  (cost=0.00..530374.00 rows=312 width=64) (actual time=554.961..1543.088 rows=142 loops=3)
         Filter: ((x &gt; &#39;1&#39;::double precision) AND (x &lt; &#39;2&#39;::double precision) AND (y &gt; &#39;1&#39;::double precision) AND (y &lt; &#39;2&#39;::double precision))
         Rows Removed by Filter: 9999858
 Planning Time: 0.313 ms
 JIT:
   Functions: 6
   Options: Inlining true, Optimization true, Expressions true, Deforming true
   Timing: Generation 4.105 ms, Inlining 158.776 ms, Optimization 773.416 ms, Emission 557.021 ms, Total 1493.318 ms
 Execution Time: 4166.328 ms
(12 rows)
</pre></div>
</div>
<p>Agora, crie um índice formado pelas colunas <code class="docutils literal notranslate"><span class="pre">x</span></code> e <code class="docutils literal notranslate"><span class="pre">y</span></code>:</p>
<div class="highlight-sql notranslate"><div class="highlight"><pre><span></span><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">pts_x_y_idx</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">pts</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Atualize as estatísticas da tabela:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">ANALYZE</span><span class="w"> </span><span class="n">pts</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Verifique novamente a execução da consulta:</p>
<div class="highlight-postgresql notranslate"><div class="highlight"><pre><span></span><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">ANALYZE</span><span class="w"></span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"></span>
<span class="w">      </span><span class="k">FROM</span><span class="w"> </span><span class="n">pts</span><span class="w"></span>
<span class="w">     </span><span class="k">WHERE</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">2.0</span><span class="w"></span>
<span class="w">       </span><span class="k">AND</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
<p>Resultado:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>                                                                     QUERY PLAN
---------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on pts  (cost=2635.91..4544.26 rows=490 width=43) (actual time=19.921..26.043 rows=425 loops=1)
   Recheck Cond: ((x &gt; &#39;1&#39;::double precision) AND (x &lt; &#39;2&#39;::double precision) AND (y &gt; &#39;1&#39;::double precision) AND (y &lt; &#39;2&#39;::double precision))
   Heap Blocks: exact=425
   -&gt;  Bitmap Index Scan on pts_x_y_idx  (cost=0.00..2635.79 rows=490 width=0) (actual time=19.731..19.732 rows=425 loops=1)
         Index Cond: ((x &gt; &#39;1&#39;::double precision) AND (x &lt; &#39;2&#39;::double precision) AND (y &gt; &#39;1&#39;::double precision) AND (y &lt; &#39;2&#39;::double precision))
 Planning Time: 0.481 ms
 Execution Time: 26.174 ms
(7 rows)
</pre></div>
</div>
<hr class="docutils" />
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>Para mais detalhes sobre o suporte de índices no PostgreSQL, consulte <a class="reference external" href="https://www.postgresql.org/docs/14/indexes.html">Chapter 11. Indexes</a>.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>Para mais detalhes sobre o comando <code class="docutils literal notranslate"><span class="pre">ANALYZE</span></code>, consulte <a class="reference external" href="https://www.postgresql.org/docs/14/sql-analyze.html">ANALYZE</a>.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>Para mais detalhes sobre o comando <code class="docutils literal notranslate"><span class="pre">EXPLAIN</span></code>, consulte <a class="reference external" href="https://www.postgresql.org/docs/14/sql-explain.html">EXPLAIN</a>.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>Para mais detalhes sobre o comando <code class="docutils literal notranslate"><span class="pre">CREATE</span> <span class="pre">INDEX</span></code>, consulte <a class="reference external" href="https://www.postgresql.org/docs/14/sql-createindex.html">CREATE INDEX</a>.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>Faça uma pesquisa para saber quando um índice pode ser utilizado na ordenação do resultado de uma consulta (<code class="docutils literal notranslate"><span class="pre">ORDER</span> <span class="pre">BY</span></code>).</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Dica</p>
<p>Procure saber sobre um recurso poderoso do PostgreSQL: <strong>Índices Parciais</strong>.</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Rodapé">
        <a href="import-export.html" class="btn btn-neutral float-left" title="2.22. Importando e Exportando Dados" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Anterior</a>
        <a href="removendo-objetos.html" class="btn btn-neutral float-right" title="2.24. Removendo Objetos do Banco de Dados" accesskey="n" rel="next">Próximo <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020-2022, Gilberto Queiroz.</p>
  </div>

  
<jinja2.runtime.BlockReference object at 0x7f7114a05cd0>
<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://mirrors.creativecommons.org/presskit/buttons/88x31/png/by-nc-sa.png" width="117" height="41"/></a> This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons “Attribution-NonCommercial-ShareAlike 4.0 International” license</a>.


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-165908761-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-165908761-1', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>